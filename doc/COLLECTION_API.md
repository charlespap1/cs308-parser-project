#Collection API

The collection which we all have the most experience with is List. This is through using ArrayLists and LinkedList. However, we all just learned this week that it is bad practice to pass a specific type of list as a parameter or as a return value for a method. So, in the future, we will be having much more interaction with the List interface in terms of making our code less “smelly” and more flexible. We all feel that collections themselves are quite easy to use. There are certain methods, such as size() and get() which you can always count on to be able to be called. Additionally, the idea of for each looping and for looping works for every type of collection. This allows you to make methods that can apply to a wide array of types of Collections. Thus, many mistakes come from not realizing that a certain method that applies to one type of collection does not apply to all collections. For example, if you used a for each loop, and within the loop decided to pop() the data structure, this loop could not be applied to a List. If you get too stuck on the attributes of one data structure, then you lose out on the flexibility in implementation which a collection provides. 

LinkedList implements 4 different interfaces (List, Deque, Cloneable, Serializable). The List interface is the foundation for different data structures that can hold indexable information. The Deque interface enables the ability to insert and remove elements at both ends of a data structure. The Cloneable interface enables a data structure to be cloned or copied. The Serializable interface enables a data structure to be serialized and deserialized.

There are about nine different classes that implement the Set collection class. I feel that this number definitely justifies there being an interface for this type of collection. If all of these types of specific implementations all require implementations of the same methods and should follow a certain format, and fit into a certain type, it makes sense that they would all implement the same collection class.

There are roughly 3 levels of superclasses for a specific concrete collection, like ArrayList. Each inheritance level gets increasingly specific, starting from the most general Object to the more specific AbstractList. Each level provides a specific collection with more functionality that is more and more relevant for that specific collection type. 

This strategy is helpful because many of the subclasses of the utility classes will have similar functionality, so it makes more sense for them all to inherit the functionality than to individually redefine the methods. Otherwise, each extension of a class like Collection would have to have its own version of methods like sort. Sometimes there is an overlap between methods of classes, but this doesn’t cause any compilation problems because calling a utility class’s method looks much different than calling a class’s own method.

